<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Appendix 2: Using cobalt with Clustered, Multiply Imputed, and Other Segmented Data • cobalt</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Appendix 2: Using cobalt with Clustered, Multiply Imputed, and Other Segmented Data">
<meta property="og:description" content="cobalt">
<meta property="og:image" content="/logo.png">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">cobalt</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">4.2.4</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../articles/cobalt.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/cobalt_A1_other_packages.html">Appendix 1: Using cobalt with Other Preprocessing Packages</a>
    </li>
    <li>
      <a href="../articles/cobalt_A2_segmented_data.html">Appendix 2: Using cobalt with Clustered, Multiply Imputed, and Other Segmented Data</a>
    </li>
    <li>
      <a href="../articles/cobalt_A3_longitudinal_treat.html">Appendix 3: Using cobalt with Longitudinal Treatments</a>
    </li>
    <li>
      <a href="../articles/cobalt_A4_love.plot.html">Appendix 4: Using love.plot To Generate Love Plots</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/ngreifer/cobalt/">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><script src="cobalt_A2_segmented_data_files/accessible-code-block-0.0.1/empty-anchor.js"></script><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Appendix 2: Using cobalt with Clustered, Multiply Imputed, and Other Segmented Data</h1>
                        <h4 class="author">Noah Greifer</h4>
            
            <h4 class="date">2020-11-16</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/ngreifer/cobalt/blob/master/vignettes/cobalt_A2_segmented_data.Rmd"><code>vignettes/cobalt_A2_segmented_data.Rmd</code></a></small>
      <div class="hidden name"><code>cobalt_A2_segmented_data.Rmd</code></div>

    </div>

    
    
<p>This is a guide for the use of <code>cobalt</code> with more complicated data than is typical in studies using propensity scores and similar methods. In particular, this guide will explain <code>cobalt</code>’s features for handling multilevel or grouped data and data arising from multiple imputation. The features described here set <code>cobalt</code> apart from other packages that assess balance because they exist only in <code>cobalt</code>. It will be assumed that the basic functions of <code>cobalt</code> are understood; this guide will only address issues that are unique to these data scenarios.</p>
<div id="cobalt-and-segmented-data" class="section level2">
<h2 class="hasAnchor">
<a href="#cobalt-and-segmented-data" class="anchor"></a><code>cobalt</code> and Segmented Data</h2>
<p>First, let’s understand segmented data. Segmented data arises when the data involved in balance assessment needs to be split into segments to appropriately assess balance. These scenarios include clustered (e.g., multilevel) data, in which case balance should be assessed within each cluster; data arising from a sequential study, in which case balance should be assessed at each time point; multi-category treatments, in which case balance should be assessed for each pair of treatments; and multiply imputed data, in which case balance should be assessed within each imputation. <code>cobalt</code> can handle all these scenarios simultaneously, but how it does so may be a little complicated. This vignette explains how these scenarios are handled.</p>
<p>At the core is the idea that the most basic unit of balance assessment is a balance statistic for a covariate For binary treatments or pairs of treatment levels, this can be the (standardized) mean difference, variance ratio, or Kolmogorov-Smirnoff (KS) statistic. For continuous treatments, this is the treatment-covariate correlation. These statistics are generated by <code><a href="../reference/bal.tab.html">bal.tab()</a></code> and can be plotted using <code><a href="../reference/love.plot.html">love.plot()</a></code> when the data are not segmented. When the data are segmented, these statistics need to be generated within each segment. When the segmentation occurs in several ways in the same dataset (e.g., with clustered and multiply imputed data, or with longitudinal data with multi-category treatments), balance assessment should reflect each layer of segmentation.</p>
<p>Although the idea of simply splitting data into segments is simple, there are a few options and limitations in <code>cobalt</code> that are important to consider. The basic idea is the same regardless of how the data are segmented: for each layer of segmentation, balance is assessed within segments of that layer, and the layers stack heirarchically. For example, for clustered and multiply imputed data, first the data are split by cluster; within each cluster, the data are split by imputation; balance statistics are computed within each imputation within each cluster. In some cases, a summary of balance across segments can be produced to simplify balance assessment. Matching and weighting are compatible with segmented data, but subclassification is its own special form of segmentation that is treated differently and will not be considered here.</p>
<p>Each of <code>cobalt</code>’s primary functions (<code><a href="../reference/bal.tab.html">bal.tab()</a></code>, <code><a href="../reference/bal.plot.html">bal.plot()</a></code>, and <code><a href="../reference/love.plot.html">love.plot()</a></code>) have features to handle segmented data sets. The following sections describe for each data scenario the relevant features of each function. We’ll take a look at a few common examples of segmented data: clustered data, multiply imputed data, and multi-category and multiply imputed data.</p>
</div>
<div id="clustered-data" class="section level2">
<h2 class="hasAnchor">
<a href="#clustered-data" class="anchor"></a>Clustered Data</h2>
<p>In clustered data, the data set must contain a variable denoting the group each individual belongs to. This may be a group considered a nuisance that must be accounted for to eliminate confounding (e.g., hospitals in a multi-site medical treatment study), or a group of concern for effect moderation (e.g., race or gender). In the examples below, we will imagine that we are interested in the ATT of <code>treat</code> on <code>re78</code> stratified by <code>race</code>. Thus, we will condition on the propensity score within each cluster.</p>
<p>First, let’s estimate propensity scores and perform matching within each race group. We can do this by performing separate analyses within each cluster, but we can also use exact matching in <code>MatchIt</code> to ensure matches occur within clusters. It is important to note that this analysis does not necessarily represent a sound statistical analysis and is being used for illustrative purposes only.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="st">"MatchIt"</span><span class="op">)</span>; <span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="st"><a href="https://ngreifer.github.io/cobalt/">"cobalt"</a></span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="st">"lalonde"</span>, package <span class="op">=</span> <span class="st">"cobalt"</span><span class="op">)</span>

<span class="va">m.out</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MatchIt/man/matchit.html">matchit</a></span><span class="op">(</span><span class="va">treat</span> <span class="op">~</span> <span class="va">race</span><span class="op">*</span><span class="op">(</span><span class="va">age</span> <span class="op">+</span> <span class="va">educ</span> <span class="op">+</span> <span class="va">married</span> <span class="op">+</span> <span class="va">nodegree</span> <span class="op">+</span> <span class="va">re74</span> <span class="op">+</span> <span class="va">re75</span><span class="op">)</span>, 
                 data <span class="op">=</span> <span class="va">lalonde</span>, method <span class="op">=</span> <span class="st">"nearest"</span>, exact <span class="op">=</span> <span class="st">"race"</span>, 
                 replace <span class="op">=</span> <span class="cn">TRUE</span>, ratio <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></code></pre></div>
<div id="bal-tab" class="section level3">
<h3 class="hasAnchor">
<a href="#bal-tab" class="anchor"></a><code>bal.tab()</code>
</h3>
<p>The output produced by <code><a href="../reference/bal.tab.html">bal.tab()</a></code> with clustered data contains balance tables for each cluster and a summary of balance across clusters. To use <code><a href="../reference/bal.tab.html">bal.tab()</a></code> with groups, there are four arguments that should be considered. These are <code>cluster</code>, <code>which.cluster</code>, <code>cluster.summary</code>, and <code>cluster.fun</code>.</p>
<ul>
<li><p><code>cluster</code> is a vector of group membership for each unit or the name of a variable in a provided data set containing group membership.</p></li>
<li><p><code>which.cluster</code> determines for which clusters balance tables are to be displayed, if any. (Default: display all clusters)</p></li>
<li><p><code>cluster.summary</code> determines whether the cluster summary is to be displayed or not. (Default: hide the cluster summary)</p></li>
<li><p><code>cluster.fun</code> determines which function(s) are used to combine balance statistics across clusters for the cluster summary. (Default: when <code>abs = FALSE</code>, minimum, mean, and maximum; when <code>abs = TRUE</code>, mean and maximum)</p></li>
</ul>
<p>The arguments are in addition to the other arguments that are used with <code><a href="../reference/bal.tab.html">bal.tab()</a></code> to display balance. <code>imp.summary</code> and <code>imp.fun</code> can also be set as global options by using <code><a href="../reference/set.cobalt.options.html">set.cobalt.options()</a></code>. Let’s examine balance on our data within each race group.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/bal.tab.html">bal.tab</a></span><span class="op">(</span><span class="va">m.out</span>, cluster <span class="op">=</span> <span class="st">"race"</span><span class="op">)</span></code></pre></div>
<pre><code>## Call
##  matchit(formula = treat ~ race * (age + educ + married + nodegree + 
##     re74 + re75), data = lalonde, method = "nearest", exact = "race", 
##     replace = TRUE, ratio = 2)
## 
## Balance by cluster
## 
##  - - - Cluster: black - - - 
## Balance Measures
##              Type Diff.Adj
## distance Distance   0.0150
## age       Contin.  -0.1001
## educ      Contin.   0.0794
## married    Binary   0.0288
## nodegree   Binary  -0.0032
## re74      Contin.  -0.1501
## re75      Contin.  -0.1406
## 
## Sample sizes
##                      Control Treated
## All                    87.       156
## Matched (ESS)          41.42     156
## Matched (Unweighted)   76.       156
## Unmatched              11.         0
## 
##  - - - Cluster: hispan - - - 
## Balance Measures
##              Type Diff.Adj
## distance Distance   0.0947
## age       Contin.   0.1914
## educ      Contin.  -0.4159
## married    Binary   0.1364
## nodegree   Binary   0.2273
## re74      Contin.   0.1161
## re75      Contin.   0.0683
## 
## Sample sizes
##                      Control Treated
## All                    61.        11
## Matched (ESS)          15.12      11
## Matched (Unweighted)   18.        11
## Unmatched              43.         0
## 
##  - - - Cluster: white - - - 
## Balance Measures
##              Type Diff.Adj
## distance Distance   0.0216
## age       Contin.  -0.4201
## educ      Contin.  -0.1403
## married    Binary  -0.0556
## nodegree   Binary   0.1111
## re74      Contin.  -0.0417
## re75      Contin.   0.0298
## 
## Sample sizes
##                      Control Treated
## All                   281.        18
## Matched (ESS)          25.92      18
## Matched (Unweighted)   31.        18
## Unmatched             250.         0
##  - - - - - - - - - - - - - -</code></pre>
<p>Here we see balance tables for each cluster. These are the same output we would see if we use <code><a href="../reference/bal.tab.html">bal.tab()</a></code> for each cluster separately (e.g., using the <code>subset</code> argument). All the commands that work for <code><a href="../reference/bal.tab.html">bal.tab()</a></code> also work here with the same results, except that balance tallies and the variable with the greatest imbalance will not be displayed as they usually are when a threshold is specified. Next, we can request a balance summary across clusters and hide the individual clusters by setting <code>which.cluster = .none</code>:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/bal.tab.html">bal.tab</a></span><span class="op">(</span><span class="va">m.out</span>, cluster <span class="op">=</span> <span class="st">"race"</span>, which.cluster <span class="op">=</span> <span class="va">.none</span><span class="op">)</span></code></pre></div>
<pre><code>## Call
##  matchit(formula = treat ~ race * (age + educ + married + nodegree + 
##     re74 + re75), data = lalonde, method = "nearest", exact = "race", 
##     replace = TRUE, ratio = 2)
## 
## Balance summary across all clusters
##              Type Min.Diff.Adj Mean.Diff.Adj Max.Diff.Adj
## distance Distance       0.0150        0.0438       0.0947
## age       Contin.      -0.4201       -0.1096       0.1914
## educ      Contin.      -0.4159       -0.1590       0.0794
## married    Binary      -0.0556        0.0366       0.1364
## nodegree   Binary      -0.0032        0.1117       0.2273
## re74      Contin.      -0.1501       -0.0252       0.1161
## re75      Contin.      -0.1406       -0.0142       0.0683
## 
## Total sample sizes across clusters
##                      Control Treated
## All                   429.       185
## Matched (ESS)          82.47     185
## Matched (Unweighted)  125.       185
## Unmatched             304.         0</code></pre>
<p>This table presents the minimum, mean, and maximum balance statistics for each variable across clusters. Setting <code>un = TRUE</code> will also display the same values for the adjusted data set. With binary treatments, setting <code>disp = c(v = TRUE)</code> or <code>thresholds = c(v = 2)</code> will display the same values for variance ratios. Setting <code>abs = TRUE</code> requests summaries of absolute balance statistics which displays the extremeness of balance statistics for each variable; thus, if, for example, in some groups there are large negative mean differences and in other groups there are large positive mean differences, this table will display large mean differences, even though the average mean difference is close to 0. While it’s important to know the average balance statistic overall, assessing the absolute balance statistics provides more information about balance within each cluster rather than in aggregate.</p>
<p>To examine balance for just a few clusters at a time, users can enter values for <code>which.cluster</code>. This can be a vector of clusters indices (i.e., 1, 2, 3, etc.) or names (e.g., “black”, “hispan”, “white”). Users also specify <code>which.cluster = .none</code> as above to omit cluster balance for all clusters and just see the summary across clusters. Users can force display of the summary across clusters by specifying <code>TRUE</code> or <code>FALSE</code> for <code>cluster.summary</code>. When <code>which.cluster = .none</code>, <code>cluster.summary</code> will automatically be set to <code>TRUE</code> (or else there wouldn’t be any output!). When examining balance within a few groups, it can be more helpful to examine balance within each group and ignore the summary. Below are examples of the use of <code>which.cluster</code> and <code>cluster.summary</code> to change <code><a href="../reference/bal.tab.html">bal.tab()</a></code> output.</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">#Just for black</span>
<span class="fu"><a href="../reference/bal.tab.html">bal.tab</a></span><span class="op">(</span><span class="va">m.out</span>, cluster <span class="op">=</span> <span class="st">"race"</span>, which.cluster <span class="op">=</span> <span class="st">"black"</span><span class="op">)</span></code></pre></div>
<pre><code>## Call
##  matchit(formula = treat ~ race * (age + educ + married + nodegree + 
##     re74 + re75), data = lalonde, method = "nearest", exact = "race", 
##     replace = TRUE, ratio = 2)
## 
## Balance by cluster
## 
##  - - - Cluster: NA - - - 
## Balance Measures
##              Type Diff.Adj
## distance Distance   0.0150
## age       Contin.  -0.1001
## educ      Contin.   0.0794
## married    Binary   0.0288
## nodegree   Binary  -0.0032
## re74      Contin.  -0.1501
## re75      Contin.  -0.1406
## 
## Sample sizes
##                      Control Treated
## All                    87.       156
## Matched (ESS)          41.42     156
## Matched (Unweighted)   76.       156
## Unmatched              11.         0
##  - - - - - - - - - - - - -</code></pre>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">#Just the balance summary across clusters with only the mean</span>
<span class="fu"><a href="../reference/bal.tab.html">bal.tab</a></span><span class="op">(</span><span class="va">m.out</span>, cluster <span class="op">=</span> <span class="st">"race"</span>, which.cluster <span class="op">=</span> <span class="va">.none</span>, cluster.fun <span class="op">=</span> <span class="st">"mean"</span><span class="op">)</span></code></pre></div>
<pre><code>## Call
##  matchit(formula = treat ~ race * (age + educ + married + nodegree + 
##     re74 + re75), data = lalonde, method = "nearest", exact = "race", 
##     replace = TRUE, ratio = 2)
## 
## Balance summary across all clusters
##              Type Mean.Diff.Adj
## distance Distance        0.0438
## age       Contin.       -0.1096
## educ      Contin.       -0.1590
## married    Binary        0.0366
## nodegree   Binary        0.1117
## re74      Contin.       -0.0252
## re75      Contin.       -0.0142
## 
## Total sample sizes across clusters
##                      Control Treated
## All                   429.       185
## Matched (ESS)          82.47     185
## Matched (Unweighted)  125.       185
## Unmatched             304.         0</code></pre>
<p>These can also be set as global options by using, for example, <code><a href="../reference/set.cobalt.options.html">set.cobalt.options(cluster.fun = "mean")</a></code>, which allows users not to type a non-default option every time they call <code>bal.tab</code>.</p>
</div>
<div id="bal-plot" class="section level3">
<h3 class="hasAnchor">
<a href="#bal-plot" class="anchor"></a><code>bal.plot()</code>
</h3>
<p><code><a href="../reference/bal.plot.html">bal.plot()</a></code> functions as it does with non-clustered data, except that multiple plots can be produced at the same time displaying balance for each cluster. The arguments to <code><a href="../reference/bal.plot.html">bal.plot()</a></code> are the same as those for <code><a href="../reference/bal.tab.html">bal.tab()</a></code>, except that <code>cluster.summary</code> is absent. Below is an example of the use of <code><a href="../reference/bal.plot.html">bal.plot()</a></code> with clustered data:</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/bal.plot.html">bal.plot</a></span><span class="op">(</span><span class="va">m.out</span>, var.name <span class="op">=</span> <span class="st">"age"</span>, cluster <span class="op">=</span> <span class="st">"race"</span>, which <span class="op">=</span> <span class="st">"both"</span><span class="op">)</span></code></pre></div>
<p><img src="cobalt_A2_segmented_data_files/figure-html/unnamed-chunk-6-1.png" width="480"></p>
<p>Balance plots for each cluster are displayed next to each other. You can specify <code>which.cluster</code> as with <code><a href="../reference/bal.tab.html">bal.tab()</a></code> to restrict plotting to a subset of clusters.</p>
</div>
<div id="love-plot" class="section level3">
<h3 class="hasAnchor">
<a href="#love-plot" class="anchor"></a><code>love.plot()</code>
</h3>
<p><code><a href="../reference/love.plot.html">love.plot()</a></code> shines with clustered data because there are several options that are unique to <code>cobalt</code> and help with the visual display of balance. One way to display cluster balance with <code><a href="../reference/love.plot.html">love.plot()</a></code> is to produce different plots for each cluster, as <code><a href="../reference/bal.plot.html">bal.plot()</a></code> does. This method should not be used with many clusters, or the plots will be unreadable. In our present example, this is not an issue. To do so, the <code>which.cluster</code> argument in <code><a href="../reference/bal.tab.html">bal.tab()</a></code> or <code><a href="../reference/love.plot.html">love.plot()</a></code> must be set to the names or indices of the clusters for which balance is to be plotted. If <code>which.cluster</code> is set to <code>.all</code> (the default), all clusters will be plotted. Below is an example:</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/love.plot.html">love.plot</a></span><span class="op">(</span><span class="va">m.out</span>, cluster <span class="op">=</span> <span class="st">"race"</span><span class="op">)</span></code></pre></div>
<p><img src="cobalt_A2_segmented_data_files/figure-html/unnamed-chunk-7-1.png" width="480"></p>
<p>These plots function like those from using <code><a href="../reference/love.plot.html">love.plot()</a></code> with non-clustered data, except that they cannot be sorted based on the values of the balance statistics (they can still be sorted alphabetically, though). This is to ensure that the covariates line up across the plots. The same axis limits will apply to all plots.</p>
<p>Second, balance can be displayed summarizing across clusters by plotting an aggregate function (i.e., the mean or maximum) of the balance statistic for each covariate across clusters. To do this, <code>which.cluster</code> in the <code>love.plot</code> command must be set to <code>.none</code>. To change which aggregate function is displayed, use the argument to <code>agg.fun</code>, which may be “mean” or “max”. Below is an example:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/love.plot.html">love.plot</a></span><span class="op">(</span><span class="va">m.out</span>, cluster <span class="op">=</span> <span class="st">"race"</span>, which.cluster <span class="op">=</span> <span class="va">.none</span>, agg.fun <span class="op">=</span> <span class="st">"mean"</span><span class="op">)</span></code></pre></div>
<p><img src="cobalt_A2_segmented_data_files/figure-html/unnamed-chunk-8-1.png" width="480"></p>
<p>A third option is to set <code>agg.fun = "range"</code> (the default), which produces a similar plot as above except that the minimum and maximum values of the balance statistics for each covariate are displayed as well. See below for an example:</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/love.plot.html">love.plot</a></span><span class="op">(</span><span class="va">m.out</span>, cluster <span class="op">=</span> <span class="st">"race"</span>, which.cluster <span class="op">=</span> <span class="va">.none</span>, agg.fun <span class="op">=</span> <span class="st">"range"</span><span class="op">)</span></code></pre></div>
<p><img src="cobalt_A2_segmented_data_files/figure-html/unnamed-chunk-9-1.png" width="480"></p>
<p>Each point represents the mean balance statistic, and the bars represent intervals bounded by the minimum and maximum of each balance statistic. This display can be especially helpful with many clusters given that the mean alone may not tell the whole story. In some cases, it might be useful to set limits on the x-axis by using the <code>limits</code> argument in <code><a href="../reference/love.plot.html">love.plot()</a></code>; doing so may cut off some of the ranges, but whatever is left will be displayed. All <code><a href="../reference/love.plot.html">love.plot()</a></code> arguments work with these methods as they do in the case of non-clustered data. When <code>var.order</code> is specified as <code>"unadjusted"</code> or <code>"adjusted"</code>, the ordering will occur on the mean balance statistic when using <code>agg.fun = "range"</code>. Only one argument to <code>stats</code> is allowed when segmented data produces more than one plot (i.e., as it would with <code>which.cluster = .all</code>).</p>
</div>
</div>
<div id="multiply-imputed-data" class="section level2">
<h2 class="hasAnchor">
<a href="#multiply-imputed-data" class="anchor"></a>Multiply Imputed Data</h2>
<p>Multiply imputed data works in a very similar way to clustered data, except the “grouping” variable refers to imputations rather than clusters. Thus, each row belongs to one imputation (i.e., the data set should be in “long” format). The data set used should only include the imputed data sets and not the original data set with missing values (unlike Stata’s <code>mi</code> commands, which do require the original data set as well). The imputed data sets can be of different sizes (i.e., because matching reduced the size of each differently), but it is preferred that they are the same size and weights are used to indicate which units belong to the sample and which do not.</p>
<p>In the example below, we will use a version of the Lalonde data set with some values missing. We will use the <code>mice</code> package to implement multiple imputation with chained equations. We will perform the “within” approach using the <code>MatchThem</code> to perform propensity score weighting within each imputation with <code>educ</code> as the continuous treatment (substantively this analysis makes no sense and is just for illustration).</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="st"><a href="https://github.com/amices/mice">"mice"</a></span><span class="op">)</span>; <span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="st"><a href="https://github.com/FarhadPishgar/MatchThem">"MatchThem"</a></span><span class="op">)</span>; <span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="st"><a href="https://ngreifer.github.io/cobalt/">"cobalt"</a></span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="st">"lalonde_mis"</span>, package <span class="op">=</span> <span class="st">"cobalt"</span><span class="op">)</span>

<span class="co">#Generate imputed data sets</span>
<span class="va">m</span> <span class="op">&lt;-</span> <span class="fl">10</span> <span class="co">#number of imputed data sets</span>
<span class="va">imp.out</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://amices.org/mice/reference/mice.html">mice</a></span><span class="op">(</span><span class="va">lalonde_mis</span>, m <span class="op">=</span> <span class="va">m</span>, print <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span> 


<span class="co">#Performing generalized propensity score weighting in each imputation</span>
<span class="va">wt.out</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MatchThem/man/weightthem.html">weightthem</a></span><span class="op">(</span><span class="va">educ</span> <span class="op">~</span> <span class="va">age</span> <span class="op">+</span> <span class="va">race</span> <span class="op">+</span> <span class="va">married</span> <span class="op">+</span> 
                      <span class="va">re74</span> <span class="op">+</span> <span class="va">re75</span>, datasets <span class="op">=</span> <span class="va">imp.out</span>, 
                     approach <span class="op">=</span> <span class="st">"within"</span>, method <span class="op">=</span> <span class="st">"ps"</span><span class="op">)</span></code></pre></div>
<pre><code>## Estimating weights     | dataset: #1 #2 #3 #4 #5 #6 #7 #8 #9 #10</code></pre>
<div id="bal-tab-1" class="section level3">
<h3 class="hasAnchor">
<a href="#bal-tab-1" class="anchor"></a><code>bal.tab()</code>
</h3>
<p>There are a few ways to use <code><a href="../reference/bal.tab.html">bal.tab()</a></code> with our imputed data sets. When using the <code>mimids</code> or <code>wimids</code> methods for <code>MatchThem</code> objects, only the output object needs to be supplied. When using other methods, an argument to <code>imp</code> can be supplied; this should contain the imputation identifiers for each unit or the name of a variable in a supplied dataset (e.g., through the <code>data</code> argument) that contains the imputation identifiers. Alternatively, the <code>mids</code> object resulting from the call to <code>mice</code> can be supplied to the <code>data</code> argument, which automatically populates <code>imp</code>. There are four arguments that are only relevant to imputed data:</p>
<ul>
<li><p><code>imp</code> is a vector of imputation numbers for each unit or the name of a variable in an available data set containing the imputation numbers. If <code>data</code> is a <code>mids</code> object or if the <code>mimids</code> or <code>wimids</code> methods are used, this doesn’t need to be specified.</p></li>
<li><p><code>which.imp</code> determines for which imputation balance assessment is to be displayed. Often it can be useful to examine balance in just a few imputations for a detailed examination of what is going on. Can be <code>.all</code> to display all imputations (not recommended), <code>.none</code> to display none, or a vector providing the imputation numbers for the desired imputations. (Default: no imputations are displayed.)</p></li>
<li><p><code>imp.summary</code> determines whether to display a summary of balance across imputations. (Default: the summary of balance across imputations is displayed.)</p></li>
<li><p><code>imp.fun</code> determines which function(s) are used to combine balance statistics across imputations for the summary of balance across imputations. (Default: when <code>abs = FALSE</code>, minimum, mean, and maximum; when <code>abs = TRUE</code>, mean and maximum)</p></li>
</ul>
<p><code>imp.summary</code> and <code>imp.fun</code> can also be set as global options by using <code><a href="../reference/set.cobalt.options.html">set.cobalt.options()</a></code> like the corresponding cluster options.</p>
<p>In many cases, not all variables are imputed, and often the treatment variable is not imputed. If each imputation has the same number of units, you can specify other arguments (e.g., treatment, distance) by specifying an object of the length of one imputation, and this vector will be applied to all imputations. This will come in handy when supplying additional covariates that weren’t involved in the imputation or propensity score estimation through <code>addl</code>. To do this, the imputed data set must be sorted by imputation and unit ID.</p>
<p>Because we’re using a <code>wimids</code> object, we can just call <code><a href="../reference/bal.tab.html">bal.tab()</a></code> with it as the first argument.</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">#Checking balance on the output object</span>
<span class="fu"><a href="../reference/bal.tab.html">bal.tab</a></span><span class="op">(</span><span class="va">wt.out</span><span class="op">)</span></code></pre></div>
<pre><code>## Balance summary across all imputations
##                Type Min.Corr.Adj Mean.Corr.Adj Max.Corr.Adj
## age         Contin.       0.0209        0.0410       0.0550
## race_black   Binary      -0.0562       -0.0419      -0.0222
## race_hispan  Binary       0.0036        0.0096       0.0132
## race_white   Binary       0.0138        0.0348       0.0481
## married      Binary       0.0245        0.0424       0.0505
## re74        Contin.      -0.0769       -0.0124       0.0110
## re75        Contin.      -0.0465       -0.0072       0.0098
## 
## Average effective sample sizes across imputations
##             Total
## Unadjusted 614.  
## Adjusted   537.75</code></pre>
<p>First, we see a balance summary across all the imputations. This table presents the minimum, mean, and maximum balance statistics for each variable across imputations. Setting <code>un = TRUE</code> will also display the same values for the adjusted data set. Setting <code>abs = TRUE</code> will make <code>bal.tab</code> report summaries of the absolute values of the balance statistics. This table functions in the same way as the table for balance across clusters. Below is the average sample size across imputations; in some matching and weighting schemes, the sample size (or effective sample size) may differ across imputations.</p>
<p>To view balance on individual imputations, you can specify an imputation number to <code>which.imp</code>. (The summary across imputations is automatically hidden but can be forced to be displayed using <code>imp.summary</code>.)</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/bal.tab.html">bal.tab</a></span><span class="op">(</span><span class="va">wt.out</span>, which.imp <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></code></pre></div>
<pre><code>## Balance by imputation
## 
##  - - - Imputation 1 - - - 
## Balance Measures
##                Type Corr.Adj
## age         Contin.   0.0526
## race_black   Binary  -0.0562
## race_hispan  Binary   0.0110
## race_white   Binary   0.0479
## married      Binary   0.0478
## re74        Contin.   0.0110
## re75        Contin.   0.0018
## 
## Effective sample sizes
##             Total
## Unadjusted 614.  
## Adjusted   531.41
##  - - - - - - - - - - - - - -</code></pre>
<p>As with clustered data, all <code><a href="../reference/bal.tab.html">bal.tab()</a></code> options work as with non-imputed data. Indeed, the functions for clustered and imputed data are nearly identical except that for imputed data, <code><a href="../reference/bal.tab.html">bal.tab()</a></code> computes the average sample size across imputations, whereas for other forms of segmented data, <code><a href="../reference/bal.tab.html">bal.tab()</a></code> computes the total sample size across groups.</p>
</div>
<div id="bal-plot-1" class="section level3">
<h3 class="hasAnchor">
<a href="#bal-plot-1" class="anchor"></a><code>bal.plot()</code>
</h3>
<p><code><a href="../reference/bal.plot.html">bal.plot()</a></code> works with imputed data as it does with non-imputed data, except that multiple plots can be produced displaying balance for multiple imputations at a time. The arguments to <code><a href="../reference/bal.plot.html">bal.plot()</a></code> are the same as those for <code><a href="../reference/bal.tab.html">bal.tab()</a></code>, except that <code>imp.summary</code> is absent. Below is an example of the use of <code><a href="../reference/bal.plot.html">bal.plot()</a></code> with imputed and matched data from <code>MatchThem</code>, examining balance in the first imputation:</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/bal.plot.html">bal.plot</a></span><span class="op">(</span><span class="va">wt.out</span>, which.imp <span class="op">=</span> <span class="fl">1</span>, var.name <span class="op">=</span> <span class="st">"age"</span>, which <span class="op">=</span> <span class="st">"both"</span><span class="op">)</span></code></pre></div>
<p><img src="cobalt_A2_segmented_data_files/figure-html/unnamed-chunk-13-1.png" width="480"></p>
<p>When many imputations are generated, it is recommended not to plot all at the same time by specifying an argument to <code>which.imp</code>, as done above.</p>
</div>
<div id="love-plot-1" class="section level3">
<h3 class="hasAnchor">
<a href="#love-plot-1" class="anchor"></a><code>love.plot()</code>
</h3>
<p><code><a href="../reference/love.plot.html">love.plot()</a></code> functions with imputed data as it does with clustered data. It is not recommended to display balance for multiple imputations at a time, and rather to display balance summarized across imputations:</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/love.plot.html">love.plot</a></span><span class="op">(</span><span class="va">wt.out</span>, threshold <span class="op">=</span> <span class="fl">.05</span><span class="op">)</span></code></pre></div>
<p><img src="cobalt_A2_segmented_data_files/figure-html/unnamed-chunk-14-1.png" width="480"></p>
<p>Often these ranges will be small if the imputed data sets are very similar to each other, but the more imputations are generated, the wider the ranges tend to be.</p>
</div>
</div>
<div id="multi-category-treatments-with-multiply-imputed-data" class="section level2">
<h2 class="hasAnchor">
<a href="#multi-category-treatments-with-multiply-imputed-data" class="anchor"></a>Multi-Category Treatments with Multiply Imputed Data</h2>
<p>So far we’ve seen how <code>cobalt</code> functions work with one layer of data segmentation, but now let’s see what it’s like to work with two or more layers of segmentation. As an example, we’ll first look at multiply imputed data with a multi-category treatment. With multi-category treatments, balance is typically assessed by examining balance statistics computed for pairs of treatments. With multi-category and multiply imputed data, the data is segmented both by imputation and by treatment pair.</p>
<p>We’ll use the three-category <code>race</code> variable as our multi-category treatment and use the same imputed data as above. Again, the <code>MatchThem</code> package can be used to estimate weights in multiply imputed data. We’ll use propensity score weighting to estimate the ATE of <code>race</code>. As before, this analysis makes no sense substantively and is just for illustration.</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">#Estimate weights within each imputation using propensity scores</span>
<span class="va">wt3.out</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MatchThem/man/weightthem.html">weightthem</a></span><span class="op">(</span><span class="va">race</span> <span class="op">~</span> <span class="va">age</span> <span class="op">+</span> <span class="va">educ</span> <span class="op">+</span> <span class="va">married</span> <span class="op">+</span> 
                        <span class="va">nodegree</span> <span class="op">+</span> <span class="va">re74</span> <span class="op">+</span> <span class="va">re75</span>, 
                      datasets <span class="op">=</span> <span class="va">imp.out</span>, approach <span class="op">=</span> <span class="st">"within"</span>, 
                      method <span class="op">=</span> <span class="st">"ps"</span>, estimand <span class="op">=</span> <span class="st">"ATE"</span><span class="op">)</span></code></pre></div>
<pre><code>## Estimating weights     | dataset: #1 #2 #3 #4 #5 #6 #7 #8 #9 #10</code></pre>
<div id="bal-tab-2" class="section level3">
<h3 class="hasAnchor">
<a href="#bal-tab-2" class="anchor"></a><code>bal.tab()</code>
</h3>
<p>Using <code><a href="../reference/bal.tab.html">bal.tab()</a></code> on the resulting object does the following: for each pair of treatments, balance is assessed for each imputation and aggregated across imputations. That is, for each pair of treatments, everything described in the previous section will occur.</p>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/bal.tab.html">bal.tab</a></span><span class="op">(</span><span class="va">wt3.out</span><span class="op">)</span></code></pre></div>
<pre><code>## Balance by treatment pair
## 
##  - - - black (0) vs. hispan (1) - - - 
## Balance summary across all imputations
##             Type Min.Diff.Adj Mean.Diff.Adj Max.Diff.Adj
## age      Contin.      -0.0148        0.0079       0.0260
## educ     Contin.      -0.1103       -0.1001      -0.0860
## married   Binary      -0.0358       -0.0290      -0.0246
## nodegree  Binary       0.0372        0.0452       0.0518
## re74     Contin.      -0.1229       -0.0867      -0.0466
## re75     Contin.      -0.1037       -0.0852      -0.0621
## 
## Average effective sample sizes across imputations
##             black hispan
## Unadjusted 243.    72.  
## Adjusted   155.92  55.61
## 
##  - - - black (0) vs. white (1) - - - 
## Balance summary across all imputations
##             Type Min.Diff.Adj Mean.Diff.Adj Max.Diff.Adj
## age      Contin.       0.0116        0.0353       0.0527
## educ     Contin.      -0.0684       -0.0573      -0.0369
## married   Binary       0.0027        0.0056       0.0084
## nodegree  Binary       0.0100        0.0182       0.0222
## re74     Contin.      -0.1460       -0.1138      -0.0791
## re75     Contin.      -0.1295       -0.1046      -0.0747
## 
## Average effective sample sizes across imputations
##             black white
## Unadjusted 243.   299. 
## Adjusted   155.92 260.5
## 
##  - - - hispan (0) vs. white (1) - - - 
## Balance summary across all imputations
##             Type Min.Diff.Adj Mean.Diff.Adj Max.Diff.Adj
## age      Contin.       0.0025        0.0274       0.0470
## educ     Contin.       0.0363        0.0428       0.0491
## married   Binary       0.0305        0.0346       0.0418
## nodegree  Binary      -0.0320       -0.0270      -0.0189
## re74     Contin.      -0.0399       -0.0271      -0.0020
## re75     Contin.      -0.0373       -0.0193      -0.0047
## 
## Average effective sample sizes across imputations
##            hispan white
## Unadjusted  72.   299. 
## Adjusted    55.61 260.5
##  - - - - - - - - - - - - - - - - - - - -</code></pre>
<p>Other options can be supplied to choose how balance is computed with multi-category treatments; these are described at <code>?bal.tab.multi</code> and in the main vignette. Importantly, though, a balance summary across treatment pairs is not available.</p>
</div>
<div id="bal-plot-2" class="section level3">
<h3 class="hasAnchor">
<a href="#bal-plot-2" class="anchor"></a><code>bal.plot()</code>
</h3>
<p><code><a href="../reference/bal.plot.html">bal.plot()</a></code> works with multi-category treatments the same way it does with binary treatments. All treatment levels are displayed on the same plot. As before, with multiply imputed data, balance can be examined on one or more imputations at a time.</p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/bal.plot.html">bal.plot</a></span><span class="op">(</span><span class="va">wt3.out</span>, var.name <span class="op">=</span> <span class="st">"married"</span>, which.imp <span class="op">=</span> <span class="fl">1</span>,
         which <span class="op">=</span> <span class="st">"both"</span><span class="op">)</span></code></pre></div>
<p><img src="cobalt_A2_segmented_data_files/figure-html/unnamed-chunk-17-1.png" width="480"></p>
</div>
<div id="love-plot-2" class="section level3">
<h3 class="hasAnchor">
<a href="#love-plot-2" class="anchor"></a><code>love.plot()</code>
</h3>
<p>With multiple layers of segmentation, <code><a href="../reference/love.plot.html">love.plot()</a></code> has a few options. Before, we saw that we could facet the plot by the segments or aggregate across segments; with multiple layers, we can do both. <code><a href="../reference/love.plot.html">love.plot()</a></code> can aggregate across as many layers as there are and can facet with segments of one layer. With more than two layers of segmentation, at least one of the <code>which.</code> arguments must be <code>.none</code> (to aggregate) or of length 1 (to facet at one segment of the layer). Here we’ll demonstrate aggregating across imputations while faceting on treatment pairs.</p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/love.plot.html">love.plot</a></span><span class="op">(</span><span class="va">wt3.out</span>, threshold <span class="op">=</span> <span class="fl">.1</span>, agg.fun <span class="op">=</span> <span class="st">"mean"</span><span class="op">)</span></code></pre></div>
<p><img src="cobalt_A2_segmented_data_files/figure-html/unnamed-chunk-18-1.png" width="480"></p>
<p>The arguments to <code>which.treat</code>, <code>which.imp</code>, <code>abs</code>, and <code>agg.fun</code> can be used to control how the plots are faceted and aggregated as they can with single-layer data.</p>
</div>
</div>
<div id="concluding-remarks" class="section level2">
<h2 class="hasAnchor">
<a href="#concluding-remarks" class="anchor"></a>Concluding Remarks</h2>
<p>We have demonstrated the use of <code>cobalt</code> with clustered data, multiply imputed data, and multiply imputed data with a multi-category treatment. Though there are few published recommendations for the display of balance in some of these cases, we believe these tools may encourage development in this area. In general, we believe in displaying the most relevant information as compactly as possible, and thus recommend using <code><a href="../reference/love.plot.html">love.plot()</a></code> with some degree of aggregation for inclusion in published work.</p>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p>Developed by Noah Greifer.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.6.1.9000.</p>
</div>

      </footer>
</div>

  


  </body>
</html>
